import time
import logging
import os
from pathlib import Path
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Poll
from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, PollAnswerHandler, JobQueue, CallbackContext
from datetime import datetime, time as dt_time
from dotenv import load_dotenv
import openpyxl
from openpyxl.styles import PatternFill
from openpyxl import Workbook, load_workbook
import csv
from datetime import datetime, timezone
import random


# Load environment variables
load_dotenv(dotenv_path=Path('.') / 'trafee.env')

# Timer for quiz
QUIZ_TIMEOUT_SECONDS = 30

# Global mapping of usernames to chat IDs
joined_users = {}  # username -> chat_id
user_chat_mapping = {}
poll_participants = {}  # poll_id -> set(user_id)
user_participation = {} # –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–æ–º–∞–Ω–¥—ã —Å—Ç–∞—Ä—Ç
quiz_participation= {} # –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –£—á–∞—Å—Ç–∏—è –≤ –≤–∏–∫—Ç–æ—Ä–∏–Ω–µ
notified_winners_global = set()

# –°–ø–∏—Å–æ–∫ –ø—Ä–∏–∑–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–Ω—è –≤–∏–∫—Ç–æ—Ä–∏–Ω—ã
prizes = [
    "is a 1-month Spotify Premium subscription!",
    "is a $20 Amazon gift card!",
    "is a 1-month Netflix subscription!",
    "is exclusive merchandise from our company!",
    "is a 1-month YouTube Premium subscription!",
    "is a bestselling e-book!",
    "is a $15 food delivery voucher!"
]


# Function to update chat ID mapping
def update_user_chat_mapping(username, chat_id):
    if username and chat_id:
        user_chat_mapping[username] = chat_id

def get_chat_id_by_username(username):
    return user_chat_mapping.get(username)

# Function to load authorized usernames from CSV
def load_authorized_usernames(file_path):
    usernames = []
    try:
        with open(file_path, mode="r", encoding="utf-8") as file:
            reader = csv.DictReader(file)
            for row in reader:
                if "Telegram Username" in row:
                    usernames.append(row["Telegram Username"])
    except FileNotFoundError:
        logging.warning(f"‚ö†Ô∏è File {file_path} not found. Authorized user list will be empty.")
    except Exception as e:
        logging.error(f"‚ö†Ô∏è Error reading file {file_path}: {e}")
    return usernames

# Configuration for users and admins
csv_file_path = "registration_log.csv"
authorized_usernames = load_authorized_usernames(csv_file_path)
SUPERADMIN_USERNAME = "Alexander_Dym"
file_path = "updated_bot_list.xlsx"

# Initialize the Excel file
def initialize_excel():
    if not os.path.exists(file_path):
        wb = Workbook()
        for i in range(1, 8):
            sheet = wb.create_sheet(title=f"Day {i}")
            headers = ["User ID", "Username", "Response Time", "Correct Answer", "Winner"]
            sheet.append(headers)
        wb.remove(wb["Sheet"])
        wb.save(file_path)
        logging.info(f"Excel file initialized with sheets for each quiz day at {file_path}")


# Class for quiz questions
class QuizQuestion:
    def __init__(self, question="", answers=None, correct_answer=""):
        self.question = question
        self.answers = answers if answers is not None else []
        self.correct_answer = correct_answer
        self.correct_answer_position = self.__get_correct_answer_position__()

    def __get_correct_answer_position__(self):
        for index, answer in enumerate(self.answers):
            if answer.strip().lower() == self.correct_answer.strip().lower():
                return index
        return -1

# Quiz questions for 7 days
quiz_questions = [
    QuizQuestion("What is an offer? üéÑüéÖ", ["A call-to-action on a landing page like Hurry up for gifts! üéÅ", "A product or service that the advertiser pays for", "Creative content used in advertising, like a holiday card from Santa ‚ùÑÔ∏è"], "A product or service that the advertiser pays for"),
    QuizQuestion("Which button is most commonly used for calls-to-action on Christmas's landing pages? üéÑüéÅ", ["Read more", "Share", "Buy now"], "Buy now"),
    QuizQuestion("Which social media became the favourite among affiliates during the holiday season thanks to short and dynamic videos? üé•‚ú®", ["Facebook", "TikTok", "Twitter"], "TikTok"),
    QuizQuestion("Which advertising strategy —Åan find the most magical ad for the upcoming holidays? üéÖüéÑ", ["Scaling", "A/B testing", "Retargeting"], "A/B testing"),
    QuizQuestion("What's the metric that measures your earnings per visitor? üéÖüí∞", ["EPC (Earnings Per Click)", "CTR (Click-Through Rate)", "CPA (Cost Per Action)"], "EPC (Earnings Per Click)"),
    QuizQuestion("What is ROI in affiliate marketing? üéÅüìà", ["Ad impressions", "Return on investment and campaign profitability", "Revenue per individual sale"], "Return on investment and campaign profitability"),
    QuizQuestion("What Does CPM Mean in Holiday Advertising? üéÖüìä", ["Cost Per Million (cost for one million clicks)", "Cost Per Millisecond (cost for one millisecond)", "Cost Per Mille (cost for one thousand impressions)"], "Cost Per Mille (cost for one thousand impressions)"),
]

# Record user response in Excel
def record_user_response(user_id, username, day, response_time, result):
    wb = load_workbook(file_path)
    sheet_name = f"Day {day + 1}"

    if sheet_name not in wb.sheetnames:
        wb.create_sheet(title=sheet_name)
    sheet = wb[sheet_name]

    green_fill = PatternFill(start_color="00FF00", end_color="00FF00", fill_type="solid")
    red_fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")
    result_text = "–í–µ—Ä–Ω–æ" if result else "–ù–µ–≤–µ—Ä–Ω–æ"
    result_fill = green_fill if result else red_fill

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –∑–∞–ø–∏—Å—å –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user_found = False
    for row in sheet.iter_rows(min_row=2, max_row=sheet.max_row):
        if row[0].value == user_id:  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ user_id
            row[2].value = response_time  # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞
            row[3].value = result_text  # –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            row[3].fill = result_fill  # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç
            user_found = True
            break

    if not user_found:
        # –ï—Å–ª–∏ –∑–∞–ø–∏—Å–∏ –Ω–µ—Ç, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é
        new_row = [user_id, username, response_time, result_text]
        sheet.append(new_row)

        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏ –∫ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–µ
        for cell in sheet.iter_rows(min_row=sheet.max_row, max_row=sheet.max_row, min_col=1, max_col=4):
            if cell[3].value == "–í–µ—Ä–Ω–æ":
                cell[3].fill = green_fill
            elif cell[3].value == "–ù–µ–≤–µ—Ä–Ω–æ":
                cell[3].fill = red_fill

    wb.save(file_path)
    logging.info(f"–†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {username} –∑–∞–ø–∏—Å–∞–Ω: {result_text}")




# Command for superadmin to get the results file
def list_handler(update, context):
    user = update.message.from_user

    if user.username == SUPERADMIN_USERNAME:
        try:
            with open(file_path, 'rb') as file:
                context.bot.send_document(chat_id=update.effective_chat.id, document=file, filename="quiz_results.xlsx")
                update.message.reply_text("üëâHere are the current quiz resultsüëà")
        except Exception as e:
            update.message.reply_text(f"Failed to send the file: {str(e)}")
    else:
        update.message.reply_text("‚õî You don't have access to this command.")

# Command to start the quiz for the user
def start_command_handler(update, context):
    user = update.effective_user
    chat_id = update.effective_chat.id
    username = user.username if user.username else "Unknown"

    # Check if the user has already started the bot
    if username in user_participation:
        # Log the repeated start attempt
        logging.warning(f"{datetime.now()} - User @{username} tried to press /start again.")
        # Send a message to the user
        context.bot.send_message(
            chat_id=chat_id,
            text="You're already in the quiz üëª\n\nThe next question will be tomorrow!\n\nDon't be sneaky üòú."
        )
        return

    # If the user is new, add them to the dictionary
    user_participation[username] = {"participated": True, "timestamp": datetime.now()}
    
    # Send the welcome message
    update_user_chat_mapping(username, chat_id)
    image_url = "https://mailer.ucliq.com/wizz/frontend/assets/files/customer/kd629xy3hj208/Trafee_quiz.png"
    welcome_text = (
        "*üéÑ‚ú® Welcome to the ultimate holiday quiz challenge! üéÖüéÅ*\n\n"
        "üî• From *December 17 to 23*, we'll light up your festive spirit with daily quizzes\n\n"
        "üéØ Answer questions, compete with others, and *grab amazing prizes every day!*\n\n"
        "*üéÅ And the grand finale?*\nA special gift waiting for the ultimate champion on Christmas Eve üéâ\n\n"
    )
    context.bot.send_photo(chat_id=chat_id, photo=image_url, caption=welcome_text, parse_mode="Markdown")

    keyboard = [[InlineKeyboardButton("üöÄ Join the Quiz", callback_data="participate")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    context.bot.send_message(chat_id=chat_id, text="Click 'Join the Quiz' to get started.\n\nLet the fun begin! üéâ", reply_markup=reply_markup)




def handle_poll_timeout(context):
    poll_id = context.job.context['poll_id']
    day = context.job.context['day']

    # List of users who have already answered
    answered_users = poll_participants.get(poll_id, set())

    # Load Excel and check who is already recorded
    wb = load_workbook(file_path)
    sheet_name = f"Day {day + 1}"
    sheet = wb[sheet_name]

    # List of users already recorded in Excel
    recorded_users = {row[0] for row in sheet.iter_rows(min_row=2, values_only=True) if row[0]}

    for username, chat_id in user_chat_mapping.items():
        user_id = chat_id  # Assuming chat_id corresponds to user_id
        if user_id in answered_users or user_id in recorded_users:
            # User has already answered, skip
            logging.info(f"User {username} has already answered the question. Timeout skipped.")
            continue

        # If the user hasn't answered, notify them and record the result
        context.bot.send_message(chat_id=chat_id, text="‚è∞ Time's up!\n\nYour response was not counted ü•µ.")
        response_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        record_user_response(user_id=user_id, username=username, day=day, response_time=response_time, result=False)

    # Proceed to selecting winners
    select_winners(context, day)


from telegram.ext import JobQueue, CallbackContext

def notify_users_about_next_day(context):
    for username, chat_id in joined_users.items():  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–∂–∞–ª–∏ Join Quiz
        try:
            context.bot.send_message(
                chat_id=chat_id,
                text="üéÑ Reminder! Tomorrow is Day 2 of our 7-day holiday giveaway! üéÅ‚ú®\n\n"
                     "Don‚Äôt miss your chance to win more amazing prizes.\n\n"
                     "üïí The fun starts at 15:00 sharp, and we‚Äôll send you a reminder 3 minutes before "
                     "to make sure you're ready to shine! üåü See you there!"
            )
            logging.info(f"Reminder for next day sent to {username} (Chat ID: {chat_id})")
        except Exception as e:
            logging.error(f"Failed to send next day reminder to {username}: {e}")
    

def select_winners(context, day):
    global notified_winners_global
    wb = load_workbook(file_path)
    sheet_name = f"Day {day + 1}"
    sheet = wb[sheet_name]

    # –°–æ–±–∏—Ä–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –¥–Ω—è
    correct_users = []
    for row in sheet.iter_rows(min_row=2, values_only=True):
        if row[3] == "–í–µ—Ä–Ω–æ" and row[4] != "Winner":  # –û—Ç–≤–µ—Ç "–í–µ—Ä–Ω–æ" –∏ –Ω–µ –æ—Ç–º–µ—á–µ–Ω –∫–∞–∫ –ø–æ–±–µ–¥–∏—Ç–µ–ª—å
            correct_users.append(row)

    if not correct_users:
        logging.info(f"No correct answers for Day {day + 1}. No winners selected.")
    else:
        # –í—ã–±–∏—Ä–∞–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π
        if len(correct_users) > 5:
            winners = random.sample(correct_users, 5)
        else:
            winners = correct_users

        prize_message = prizes[day] if day < len(prizes) else "üéÅ Today's prize will be announced later!"

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è–º
        for winner in winners:
            user_id = winner[0]
            if user_id not in notified_winners_global:
                try:
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–±–µ–¥–∏—Ç–µ–ª—é
                    context.bot.send_message(
                        chat_id=user_id,
                        text=f"üéâ Congratulations!\n\nYou are the winner of the day! üèÜ‚ú®\n\nüéÅYour prize {prize_message}\n\nü§ëPlease contact your manager to claim your prize."
                    )
                    logging.info(f"Winner notification sent to user ID: {user_id}")
                    notified_winners_global.add(user_id)

                    # –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –≤ —Ç–∞–±–ª–∏—Ü–µ
                    for row in sheet.iter_rows(min_row=2, max_row=sheet.max_row):
                        if row[0].value == user_id:  # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º user_id
                            row[len(row) - 1].value = "Winner"
                            row[len(row) - 1].fill = PatternFill(start_color="FFD700", end_color="FFD700", fill_type="solid")

                except Exception as e:
                    logging.error(f"Failed to send winner notification to user ID: {user_id}: {e}")

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ç–∞–±–ª–∏—Ü–µ
    wb.save(file_path)
    logging.info(f"Winners for Day {day + 1} have been recorded in the Excel sheet.")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞—è –∑–∞–¥–∞—á–∞ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    existing_jobs = [job.name for job in context.job_queue.jobs()]
    if "next_day_reminder" not in existing_jobs:
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –≤—Å–µ–º, –∫—Ç–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –≤–∏–∫—Ç–æ—Ä–∏–Ω–µ
        context.job_queue.run_once(
            lambda _: notify_users_about_next_day(context),
            when=5,  # –ó–∞–¥–µ—Ä–∂–∫–∞ –≤ 5 —Å–µ–∫—É–Ω–¥
            name="next_day_reminder"  # –ù–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
        )
    else:
        logging.warning("Reminder job for the next day already exists. Skipping duplicate scheduling.")


# Callback for participating in quiz
def participate_handler(update, context):
    query = update.callback_query
    query.answer()

    user = query.from_user
    chat_id = query.message.chat_id
    username = user.username if user.username else "Unknown"

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –æ–Ω –Ω–∞–∂–∞–ª Join Quiz
    if username not in joined_users:
        joined_users[username] = chat_id
        logging.info(f"User @{username} joined the quiz for the first time.")
    
    context.bot.send_message(
        chat_id=chat_id,
        text="Welcome aboard!üöÄ\n\nThe quiz starts sharp at 15:00 ü§©.\n\nRelax for now!üòé\n\nWe'll send you a reminder 3 minutes before it begins!"
    )



# Function to send quiz question
def send_daily_quiz(context, day):
    logging.info(f"Preparing to send quiz for day {day + 1}")

    if day < len(quiz_questions):
        question = quiz_questions[day]

        if not user_chat_mapping:
            logging.warning("‚ö†Ô∏è No users registered for the quiz. Skipping.")
            return

        for username, chat_id in user_chat_mapping.items():
            # Send the quiz question without mentioning the prize
            context.bot.send_message(
                chat_id=chat_id,
                text="‚ö° Today's quiz question:"
            )
            add_quiz_question(context, question, chat_id, day)

        # Update current day
        next_day = (day + 1) % len(quiz_questions)
        context.dispatcher.bot_data['current_day'] = next_day

        # Log when the next question will be sent
        next_quiz_time = context.job_queue.jobs()[1].next_t.replace(tzinfo=None)  # Get the time for the next quiz
        logging.info(f"The next question (day {next_day + 1}) will be sent at {next_quiz_time}.")
    else:
        logging.error(f"Day {day + 1} is out of range for questions.")



# Function to notify users about the quiz
def notify_users_about_quiz(context):
    for username, chat_id in joined_users.items():  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–∂–∞–ª–∏ Join Quiz
        try:
            context.bot.send_message(
                chat_id=chat_id,
                text="The quiz will start in 3 minutes!üîî\n\n"
                "üî•Get ready!"
            )
            logging.info(f"Reminder sent to {username} (Chat ID: {chat_id})")
        except Exception as e:
            logging.error(f"Failed to send reminder to {username}: {e}")



# Function to send quiz question to user
def add_quiz_question(context, quiz_question, chat_id, day):
    message = context.bot.send_poll(
        chat_id=chat_id,
        question=quiz_question.question,
        options=quiz_question.answers,
        type=Poll.QUIZ,
        correct_option_id=quiz_question.correct_answer_position,
        open_period=QUIZ_TIMEOUT_SECONDS,
        is_anonymous=False,
        explanation="Don't be sad"
    )
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –æ–ø—Ä–æ—Å–∞
    context.bot_data.update({message.poll.id: {'chat_id': message.chat.id, 'day': day}})
    
    # –ü–ª–∞–Ω–∏—Ä—É–µ–º —Ç–∞–π–º–∞—É—Ç
    context.job_queue.run_once(
        handle_poll_timeout,
        when=QUIZ_TIMEOUT_SECONDS,
        context={'poll_id': message.poll.id, 'day': day}
    )


# Poll answer handler
def poll_handler(update, context):
    poll_answer = update.poll_answer
    user_id = poll_answer.user.id
    poll_id = poll_answer.poll_id
    selected_option_id = poll_answer.option_ids[0]

    poll_data = context.bot_data.get(poll_id, {})
    day = poll_data.get('day', 0)
    question = quiz_questions[day]
    correct_option_id = question.correct_answer_position
    is_correct = (selected_option_id == correct_option_id)

    response_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    username = poll_answer.user.username if poll_answer.user.username else "Unknown"

    # Add the user to poll_participants if they are not already in it
    if poll_id not in poll_participants:
        poll_participants[poll_id] = set()
    poll_participants[poll_id].add(user_id)

    # Record the result in the table
    record_user_response(user_id=user_id, username=username, day=day, response_time=response_time, result=is_correct)

    # Send a message to the user
    if is_correct:
        context.bot.send_message(
            chat_id=user_id,
            text="üéâCongratulations, your answer is correct!\n\nüèÅWe will now wait for all participants to complete the game.\n\n‚ú®After that, we will randomly select 20 winners from those who answered correctly.\n\n‚òòÔ∏èGood luck!"
        )
    else:
        context.bot.send_message(
            chat_id=user_id,
            text="‚ùå Oops, that‚Äôs the wrong answer!\n\nBut don‚Äôt give up!\n\nü§óTry again tomorrow."
        )

# Check if user is authorized
def is_authorized_user(update):
    user = update.effective_user
    return user.username == SUPERADMIN_USERNAME or user.username in authorized_usernames

# Main function
def main():
    initialize_excel()

    TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
    if not TELEGRAM_TOKEN:
        logging.error("TELEGRAM_TOKEN is not set. Exiting.")
        return

    updater = Updater(TELEGRAM_TOKEN, use_context=True)
    dp = updater.dispatcher

    dp.add_handler(CommandHandler("start", start_command_handler))
    dp.add_handler(CommandHandler("list", list_handler))
    dp.add_handler(CallbackQueryHandler(participate_handler, pattern="participate"))
    dp.add_handler(PollAnswerHandler(poll_handler))

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ–∫—É—â–µ–≥–æ –¥–Ω—è
    dp.bot_data['current_day'] = 0  # –ù–∞—á–∏–Ω–∞–µ–º —Å 0-–≥–æ –¥–Ω—è

    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Å–µ—Ä–≤–µ—Ä–∞
    logging.info(f"Current server UTC time: {datetime.now(timezone.utc)}")

    # –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á
    job_queue = updater.job_queue
    # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∑–∞ 5 –º–∏–Ω—É—Ç –¥–æ –≤–∏–∫—Ç–æ—Ä–∏–Ω—ã
    job_queue.run_daily(
        notify_users_about_quiz,
        time=dt_time(8, 35),  # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ 14:55 –ø–æ UTC
    )
    logging.info("JobQueue task for quiz notifications added at 14:55 UTC.")

    # –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∞–º–æ–π –≤–∏–∫—Ç–æ—Ä–∏–Ω—ã
    job_queue.run_daily(
        lambda context: send_daily_quiz(context, dp.bot_data['current_day']),
        time=dt_time(8, 40)  # –í–∏–∫—Ç–æ—Ä–∏–Ω–∞ –≤ 15:00 –ø–æ UTC
    )
    logging.info("JobQueue task for quiz scheduling added at 15:00 UTC.")
    updater.start_polling()
    logging.info("Bot started in polling mode")


logging.basicConfig(format="%(asctime)s - %(levelname)s - %(message)s", level=logging.INFO)
main()